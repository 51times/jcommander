<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>JCommander</title>

      <link rel="stylesheet" href="testng.css" type="text/css" />
      <link type="text/css" rel="stylesheet" href="http://beust.com/beust.css"  />
      <script type="text/javascript" src="http://beust.com/prettify.js"></script>
      <script type="text/javascript" src="http://testng.org/doc/banner.js"></script>

      <script type="text/javascript" src="http://beust.com/scripts/shCore.js"></script>
      <script type="text/javascript" src="http://beust.com/scripts/shBrushJava.js"></script>
      <script type="text/javascript" src="http://beust.com/scripts/shBrushXml.js"></script>
      <script type="text/javascript" src="http://beust.com/scripts/shBrushBash.js"></script>
      <script type="text/javascript" src="http://beust.com/scripts/shBrushPlain.js"></script>
      <link type="text/css" rel="stylesheet" href="http://beust.com/styles/shCore.css"/>
      <link type="text/css" rel="stylesheet" href="http://beust.com/styles/shThemeCedric.css"/>
      <script type="text/javascript">
        SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
        SyntaxHighlighter.defaults['gutter'] = false;
        SyntaxHighlighter.all();
      </script>

</head>

<body>
<table width="100%">
  <tr>
    <td align="center">
<h1>JCommander</h1>
<h2>Because life is too short to parse command line parameters</h2>
    </td>
  </tr>
  <tr>
    <td align="right">
      Created: July 13th, 2010
    </td>
  </tr>
  <tr><td align="right"><a href="mailto:cedric@beust.com">C&eacute;dric Beust</a></td></tr>
</table>


<h2 id="Overview" />Overview</h2>

JCommander is a very small Java framework that makes it trivial to parse command line parameters.
<p>
You annotate fields with descriptions of your options:

<pre class="brush: java">
import com.beust.jcommander.Parameter;

public class JCommanderTest {
  @Parameter
  public List&lt;String&gt; parameters = Lists.newArrayList();

  @Parameter(names = { "-log", "-verbose" }, description = "Level of verbosity")
  public Integer verbose = 1;

  @Parameter(names = "-groups", description = "Comma-separated list of group names to be run")
  public String groups;

  @Parameter(names = "-debug", description = "Debug mode")
  public boolean debug = false;
}
</pre>

and then you simply ask JCommander to parse:

<pre class="brush: java">
JCommanderTest jct = new JCommanderTest();
String[] argv = { "-log", "2", "-groups", "unit", "a", "b", "c" };
new JCommander(jct, argv);

Assert.assertEquals(jct.verbose.intValue(), 2);
</pre>

<h2 id="Types_of_options">Types of options</h2>

The fields representing your parameters can be of any type. Basic types (<tt>Integer</tt>, <tt>Boolean</tt/>., etc...) are supported by default and you can write type converters to support any other type (<tt>File</tt>, etc...).

<h4>Boolean</h4>

When a <tt>Parameter</tt> annotation is found on a field of type <tt>boolean</tt> or <tt>Boolean</tt>, JCommander interprets it as an option with an <em>arity</em> of 0:

<pre class="brush: java">
@Parameter(names = "-debug", description = "Debug mode")
public boolean debug = false;
</pre>

Such a parameter does not require any additional parameter on the command line and if it's detected during parsing, the corresponding field will be set to <tt>true</tt>.

<h4>String, Integer, Long</h4>

When a <tt>Parameter</tt> annotation is found on a field of type <tt>String</tt>, <tt>Integer</tt>, <tt>int</tt>, <tt>Long</tt> or <tt>long</tt>, JCommander will parse the following parameter and it will attempt to cast it to the right type:

<pre class="brush: java">
@Parameter(names = "-log", description = "Level of verbosity")
public Integer verbose = 1;
</pre>

<pre class="brush: bash">
java Main -log 3
</pre>

will cause the field <tt>verbose</tt> to receive the value 3, however:

<pre class="brush: bash">
java Main -log test
</pre>

will cause an exception to be thrown.

<h4>Lists</h4>

When a <tt>Parameter</tt> annotation is found on a field of type <tt>List</tt>, JCommander will interpret it as an option that can occur multiple times:

<pre class="brush: java">
@Parameter(names = "-host", description = "The host")
public List&lt;String&gt; hosts = new ArrayList&lt;String&gt;();
</pre>

will allow you to parse the following command line:

<pre class="brush: bash">
java Main -host host1 -verbose -host host2
</pre>

When JCommander is done parsing the line above, the field <tt>hosts</tt> will contain the strings "host1" and "host2".

<h4>Password</h4>

If one of your parameters is a password or some other value that you do not wish to appear in your history or in clear, you can declare it of type <tt>password</tt> and JCommander will then ask you to enter it in the console:

<pre class="brush: java">
public class ArgsPassword {
  @Parameter(names = "-password", description = "Connection password", password = true)
  public String password;
}
</pre>

When you run your program, you will get the following prompt:

<pre class="brush: bash">
Value for -password (Connection password):
</pre>

You will need to type the value at this point before JCommander resumes.

<h4>Custom types</h4>

By default, JCommander parses the command line into basic types only (strings, booleans, integers and longs). Very often, your application actually needs more complex types, such as files, host names, lists, etc... To achieve this, you can write a type converter by implementing the following interface:

<pre class="brush: java">
public interface IStringConverter&lt;T&gt; {
  T convert(String value);
}
</pre>

For example, here is a converter that turns a string into a <tt>File</tt>:

<pre class="brush: java">
public class FileConverter implements IStringConverter&lt;File&gt; {
  @Override
  public File convert(String value) {
    return new File(value);
  }
}
</pre>

Then, all you need to do is declare your field with the correct type and specify the converter as an attribute:

<pre class="brush: java">
@Parameter(names = "-file", converter = FileConverter.class)
File file;
</pre>

JCommander ships with a few common converters (e.g. one that turns a comma separated list into a <tt>List&lt;String&gt;)</tt>.

<h4>Main parameter</h4>
So far, all the <tt>@Parameter</tt> annotations we have seen had defined an attribute called <tt>names</tt>. You can define one (and at most one) parameter without any such attribute. This parameter needs to be a <tt>List&lt;String&gt;</tt> and it will contain all the parameters that are not options:

<pre class="brush: java">
@Parameter(description = "Files")
public List&lt;String&gt; files = new ArrayList&lt;String&gt;();

@Parameter(names = "-debug", description = "Debugging level")
public Integer debug = 1;
</pre>

will allow you to parse:

<pre class="brush: bash">
java Main -debug file1 file2
</pre>

and the field <tt>files</tt> will receive the strings "file1" and "file2".

<h2 id="Private_parameters">Private parameters</h2>

Parameters can be private:

<pre class="brush: java">
public class ArgsPrivate {
  @Parameter(names = "-verbose")
  private Integer verbose = 1;

  public Integer getVerbose() {
    return verbose;
  }
}
</pre>

<pre class="brush: java">
ArgsPrivate args = new ArgsPrivate();
new JCommander(args, "-verbose", "3");
Assert.assertEquals(args.getVerbose().intValue(), 3);
</pre>

<h2 id="Separators">Parameter separators</h2>

By default, parameters are separated by spaces, but you can change this setting to allow different separators:

<pre class="brush: bash">
java Main -log:3
</pre>

or

<pre class="brush: bash">
java Main -level=42
</pre>

You define the separator with the <tt>@Parameters</tt> annotation:

<pre class="brush: java">
@Parameters(separators = "=")
public class SeparatorEqual {
  @Parameter(names = "-level")
  public Integer level = 2;
}
</pre>





<h2 id="Multiple_descriptions">Multiple descriptions</h2>

You can spread the description of your parameters on more than one
class. For example, you can define the following two classes:

<p>

<h3 class="sourcetitle">ArgsMaster.java</h3>
<pre class="brush: java">
public class ArgsMaster {
  @Parameter(names = "-master")
  public String master;
}
</pre>

<h3 class="sourcetitle">ArgsSlave.java</h3>
<pre class="brush: java">
public class ArgsSlave {
  @Parameter(names = "-slave")
  public String slave;
}
</pre>

and pass these two objects to JCommander:

<pre class="brush: java">
ArgsMaster m = new ArgsMaster();
ArgsSlave s = new ArgsSlave();
String[] argv = { "-master", "master", "-slave", "slave" };
new JCommander(new Object[] { m , s }, argv);

Assert.assertEquals(m.master, "master");
Assert.assertEquals(s.slave, "slave");
</pre>


<h2 id="Syntax">@ syntax</h2>

JCommander supports the @ syntax, which allows you to put all your options into a file and pass this file as parameter:

<p>

<div class="sourcetitle">/tmp/parameters</div>
<pre class="brush: bash">
-verbose
file1
file2
file3
</pre>
<pre class="brush: bash">
java Main @/tmp/parameters
</pre>

<h2 id="Arities">Arities (multiple values for parameters)</h2>

If some of your parameters require more than one value, such as the
following example where two values are expected after <tt>-pairs</tt>:

<pre class="brush: bash">
java Main -pairs slave master foo.xml
</pre>

then you need to define your parameter with the <tt>arity</tt>
attribute and make that parameter a <tt>List&lt;String&gt;</tt>:

<pre class="brush: java">
@Parameter(names = "-pairs", arity = 2, description = "Pairs")
public List&lt;String&gt; pairs;
</pre>

You don't need to specify an arity for parameters of type
<tt>boolean</tt> or <tt>Boolean</tt> (which have a default arity of 0)
and of types <tt>String</tt>, <tt>Integer</tt>, <tt>int</tt>,
<tt>Long</tt> and <tt>long</tt> (which have a default arity of 1).

<p>
Also, note that only <tt>List&lt;String&gt;</tt> is allowed for
parameters that define an arity. You will have to convert these values
yourself if the parameters you need are of type <tt>Integer</tt> or
other (this limitation is due to Java's erasure).

<h2 id="Multiple_option_names">Multiple option names</h2>

You can specify more than one option name:

<pre class="brush: java">

  @Parameter(names = { "-d", "--outputDirectory" }, description = "Directory")
  public String outputDirectory;

</pre>

will allow both following syntaxes:

<pre class="brush: bash">
java Main -d /tmp
java Main --outputDirectory /tmp
</pre>

<h2 id="Required_and_optional">Required and optional parameters</h2>

If some of your parameters are mandatory, you can use the
<tt>required</tt> attribute (which default to <tt>false</tt>):

<pre class="brush: java">

  @Parameter(names = "-host", required = true)
  public String host;

</pre>

If this parameter is not specified, JCommander will throw an exception
telling you which options are missing.

<h2 id="Exceptions">Exception</h2>

Whenever JCommander detects an error, it will throw a
<tt>ParameterException</tt>. Note that this is a Runtime Exception,
since your application is probably not initialized correctly at this
point.


<h2 id="Usage">Usage</h2>

You can invoke <tt>usage()</tt> on the <tt>JCommander</tt> instance that you used to parse your command line in order to generate a summary of all the options that your program understands:

<pre class="brush: bash">
Usage:
	-port			The port number
	-debug			Debug mode
	-src, --sources The source directory
	-testclass		List of classes
</pre>

<h2 id="Hiding">Hiding parameters</h2>

If you don't want certain parameters to appear in the usage, you can mark them as "hidden":

<pre class="brush: java">
@Parameter(names = "-debug", description = "Debug mode", hidden = true)
public boolean debug = false;
</pre>

<h2 id="Internationalization">Internationalization</h2>

You can internationalize the descriptions of your parameters.

<p>

First you use the <tt>@Parameters</tt> annotation at the top of your class to define the name of your message bundle, and then you use the <tt>descriptionKey</tt> attribute instead of <tt>description</tt> on all the <tt>@Parameters</tt> that require translations. This <tt>descriptionKey</tt> is the key to the string into your message bundle:

<h3 class="sourcetitle">I18N.java</h3>
<pre class="brush:java">
@Parameters(resourceBundle = "MessageBundle")
public class ArgsI18N2 {
  @Parameter(names = "-host", description = "Host", descriptionKey = "host")
  String hostName;
}
</pre>

Your bundle needs to define this key:

<br>

<h3 class="sourcetitle">MessageBundle_fr_FR.properties</h3>
<pre class="brush: bash">
host: H&ocirc;te
</pre>

JCommander will then use the default locale to resolve your descriptions.

<h2 id="More_examples">More examples</h2>

TestNG uses JCommander to parse its command line, here is <a href="http://github.com/cbeust/testng/blob/master/src/main/java/org/testng/CommandLineArgs.java">its definition file</a>.

<h2 id="Download">Download</h2>

You can download JCommander from the following locations:

<ul>
  <li><a href="http://github.com/cbeust/jcommander">Source on github</a></li>
  <li><a href="http://beust.com/jcommander-1.2-SNAPSHOT.jar">Jar file</a></li>
  <li>Or if you are using Maven, add the following dependency to your <tt>pom.xml</tt>:

  <pre class="brush: xml">

<dependency>
  <groupId>com.beust</groupId>
  <artifactId>jcommander</artifactId>
  <version>1.1</version>
</dependency>
  </pre>

  Make sure you are using <a href="http://repo2.maven.org/maven2/com/beust/jcommander/">the latest version available</a>.

</ul>

</body>

</html>
